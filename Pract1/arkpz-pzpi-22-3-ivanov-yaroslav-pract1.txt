Харківський національний університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії
    
    
    
    
    
    
ЗВІТ
з практичного заняття №1
з дисципліни  «Аналіз та рефакторинг коду»
на тему: «Правила оформлення програмного коду»
    
    
    
    
    
    
    Виконав
    ст. гр. ПЗПІ-22-3
    Іванов Ярослав В’ячеславович

    Перевірив
    ст. викладач катедри ПІ
    Сокорчук Ігор Петрович
    
    

    
Харків 2024
1 МЕТА РОБОТИ

     Ознайомитися з основними рекомендаціями щодо написання чистого, ефективного та підтримуваного коду для різних мов програмування, а також навчити аналізувати та рефакторити код для покращення його якості.
    
2 ВСТУП

    Kotlin - це сучасна мова програмування, створена компанією JetBrains у 2011 році. Вона швидко стала популярною серед розробників завдяки своїй простоті та функціональності. Kotlin дозволяє писати лаконічний, читабельний код та має високу сумісність з Java, що дозволяє інтегрувати її в існуючі проєкти. Основні переваги Kotlin включають безпеку типів, та підтримку сучасних парадигм програмування, таких як об'єктно-орієнтоване та функціональне програмування. Рефакторинг коду на Kotlin дозволяє покращити структуру та ефективність коду, зменшити його складність та підвищити надійність програмного забезпечення.
    Правильне оформлення коду на Kotlin є надзвичайно важливим для забезпечення його читабельності, підтримуваності та розширюваності. Дотримання стилістичних рекомендацій, таких як осмислені назви змінних і функцій, послідовне форматування та чітка структура, сприяє створенню коду, який легше аналізувати та рефакторити. Це особливо важливо для великих проєктів, де команди розробників повинні працювати з одним і тим же кодом протягом тривалого часу.
    
3 ХІД РОБОТИ

     Посилання на відео з демонстраціями рекомендацій оформлення коду на мові програмування Kotlin наведено у додатку А.
     Рекомендація:  Використовуйте форматувальник Ktlint задля дотримання офіційних рекомендації щодо форматування.
     Форматування коду є важливим аспектом, який впливає на читабельність, підтримуваність і ефективність командної роботи над проєктом. У мові Kotlin існують стандартизовані правила форматування, що сприяють уніфікації стилю написання коду серед розробників. Ці правила називають Kotlin Style Guide.
     Використання інструменту Ktlint забезпечить форматування коду згідно до правил Kotlin Style Guide [1]. Ktlint автоматично заміняє табуляцію на 4 пробіли, додає пробіли між операторами, правильно розташовує дужки, додає порожні рядки між функціями, а також розбиває код на кілька рядків для функцій з багатьма параметрами та використовує кінцеві коми після останніх елементів списків.
     Приклади поганого та гарного форматування наведено у додатку Б.
     Рекомендація: Дотримуйтесь офіційної конвенції іменування.
     Іменування в Kotlin відіграє важливу роль у забезпеченні читабельності та підтримуваності коду. Дотримання стандартів іменування робить код зрозумілим для всіх членів команди та зменшує ризик виникнення помилок.
     В Kotlin використовються наступні конвенції іменування:
     1) camelCase - для іменування змінних, властивостей та функцій;
     2) PascalCase - для іменування класів, об’єктів та інтерфейсів;
     3) UPPER_SNAKE_CASE  - для іменування констант;
     4) lowercase – для іменування назв пакетів;
     Приклади поганого та гарного використання конвенції найменувань наведено у додатку В.
     Рекомендація: Обирайте зрозумілі, лаконічні та логічні імена.
     Найменування файлів повинно чітко описувати, що код в цьому файлі робить, проте треба уникати використання безкорисних слів в іменування. Так само і з внутрішньою частиною коду, функції, класи, методи – повинні описувати, що робить ця частина коду. Для назви класу бажано використовувати іменникові фрази, що позначають що це за клас; для методів і функцій  – дієслівникові фрази, що позначають що цей метод або функція робить.
    Також якщо Kotlin файл містить один клас або інтерфейс – назви класу та файлу повинні співпадати.
	Приклади поганого та гарного найменування наведено у додатку Г.
     Рекомендація: Використовуйте змістовні коментарі в правильних ділянках коду.
     Коментування є важливою частиною розробки, що забезпечує легке розуміння логіки програми, її підтримку та зручність використання сторонніми розробниками.
     Коментарі мають бути змістовними. Вони повинні пояснювати, що відбувається у коді, якщо це не очевидно, або чому зроблений певний вибір, а не просто повторювати те, що вже видно. Уникайте надлишкових коментарів. Не коментуйте те, що й так зрозуміло з коду. Використовуйте коментарі для пояснення складної логіки. Якщо код складний, залишайте пояснення.
	Приклади поганого та гарного коментування наведено у додатку Д.
     Рекомендація: Використовуйте документування функціоналу.
     Kotlin підтримує інтегроване створення документації за допомогою спеціальних коментарів формату /** ... */. Ці коментарі автоматично обробляються інструментами, такими як KDoc та Javadoc, для створення читабельної документації.
     Документувальні коментарі використовуються для опису функцій, класів, методів і параметрів. Вони дозволяють включати теги для структурування.
     @param — описує параметри функції.
     @return — описує, що повертає функція.
     @throws — пояснює, які винятки можуть бути викликані.
     @see — додає посилання на інші класи або функції.
     @since — позначає, коли функція або клас були додані.
     Дотримання стандартів документування в Kotlin допомагає полегшити підтримку коду та покращити співпрацю в команді.
	Приклади поганого та гарного документування наведено у додатку Е.
     Рекомендація: Використовуйте розширення функцій
     Розширення функцій дозволяють додавати нові функції до існуючих класів без необхідності зміни їх коду або наслідування від них. Це сприяє покращенню читабельності та зменшенню дублювання коду. Вони дозволяють програмістам додавати методи до класів, які вони не контролюють, або до вже існуючих класів.	Приклади поганого та гарного використання розширення функцій наведено у додатку Ж.
     Рекомендація: Використовуйте типову безпеку та null-safe оператори.
     Kotlin має вбудовану підтримку типової безпеки, що дозволяє уникати помилок, пов'язаних із некоректними типами даних. Використання null-safe операторів і функцій допомагає запобігти NullPointerException, що є однією з найпоширеніших проблем у мовах програмування без типової безпеки.
	Приклади поганого та гарного використання типової безпеки наведено у додатку И.
     Рекомендація: Використовуйте data class для моделей даних.
     Data класи в Kotlin автоматично забезпечують основні функції, такі як equals(), hashCode(), toString(), а також підтримку copy(), що робить їх ідеальними для використання в якості моделей даних. Це значно зменшує обсяг коду і знижує ймовірність помилок.
     Приклади поганого та гарного використання дата класів наведено у додатку К
     Слайди презентації, що ілюструють результати виконання даної практичної роботи наведено у додатку Л.
ВИСНОВКИ

     Під час виконання лабораторної роботи було ознайомлено з основними рекомендаціями щодо написання чистого, ефективного та підтримуваного коду для мови програмування Kotlin, а також було набуто навичок з аналізу та рефакторингу коду для покращення його якості.


СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ

      1. Coding conventions | Kotlin. Kotlin Help. URL: https://kotlinlang.org/docs/coding-conventions.html (дата звернення: 11.12.2024).
ДОДАТОК А
Відео-посилання на YouTube

     https://youtu.be/leg-70rF_Pc 
ДОДАТОК Б
Приклади поганого та гарного форматування

1 //Поганий приклад
2 fun calculateSum(firstNumber:Int,secondNumber:Int):Int
3 {
4 var result=firstNumber+secondNumber
5 return result
6 }
7 fun createUser(name: String, age: Int, email: String) {}
8 fun main()
9 {
10 val res=calculateSum(10,20) 
11 println("Result is "+res)
12 val user = createUser("yaroslav",19,"yaroslav.ivanov@nure.ua")
13 }
14 //Гарний приклад
15 fun calculateSum(firstNumber: Int, secondNumber: Int): Int {
16     val result = firstNumber + secondNumber
17     return result
18 }
19 
20 fun createUser(
21     name: String,
22     age: Int,
23     email: String,
24 ) {}
25 
26 fun main() {
27     val result = calculateSum(10, 20)
28     println("Result is $result")
29 
30     val user = createUser(
31         "yaroslav",
32         19,
33         "yaroslav.ivanov@nure.ua"
34     )
35 }

ДОДАТОК В
Приклади поганого та гарного використання конвенції найменувань

1 //Поганий приклад
2 package Project
3 
4 class userprofile {
5     val username = "Yaroslav05"
6     fun getusername(): String {
7         return username
8     }
9 }
10 
11 fun main() {
12     val UserName = userprofile().getusername()
13     println("Username: $UserName")
14 }
15 //Гарний приклад
16 package project
17 
18 class UserProfile {
19     val USERNAME = "Yaroslav05"
20     fun getUsername(): String {
21         return USERNAME
22     }
23 }
24 
25 fun main() {
26     val userName = UserProfile().getUsername()
27     println("Username: $userName")
28 }

ДОДАТОК Г
Приклади поганого та гарного найменування

1 //Поганий приклад
2 class MyUtils {
3     fun doStuff(a: Int, b: Int): Int {
4         return a + b
5     }
6 }
7 
8 fun main() {
9     val obj = MyUtils()
10     val result = obj.doStuff(5, 10)
11     println("Result is $result")
12 }
13 //Гарний приклад
14 class MathOperations {
15     fun addNumbers(firstNumber: Int, secondNumber: Int): Int {
16         return firstNumber + secondNumber
17     }
18 }
19 
20 fun main() {
21     val mathOperations = MathOperations()
22     val result = mathOperations.addNumbers(5, 10)
23     println("Result is $result")
24 }


ДОДАТОК Д
Приклади поганого та гарного коментування

1 //Поганий приклад
2 // Клас для роботи з продуктами
3 class Product(val name: String, val price: Double)
4 
5 fun calculateTotalPrice(products: List<Product>): Double {
6     // Обчислюємо загальну ціну
7     var total = 0.0
8     // Перебираємо всі продукти
9     for (product in products) {
10         // Додаємо ціну продукту до загальної
11         total += product.price
12     }
13     // Повертаємо загальну ціну
14     return total
15 }
16 
17 fun main() {
18     // Створюємо список продуктів
19     val products = listOf(
20         Product("Apple", 1.0),
21         Product("Banana", 0.5),
22         Product("Orange", 0.75)
23     )
24     // Обчислюємо загальну ціну продуктів
25     val totalPrice = calculateTotalPrice(products)
26     // Виводимо загальну ціну продуктів
27     println("Total price: $totalPrice")
28 }
29 //Гарний приклад
30 // Клас, що представляє продукт з іменем і ціною
31 class Product(val name: String, val price: Double)
32 
33 // Обчислює загальну ціну всіх продуктів зі списку.
34 fun calculateTotalPrice(products: List<Product>): Double {
35     var total = 0.0
36 
37     for (product in products) {
38         total += product.price
39     }
40 
41     return total
42 }
43 
44 // Основна функція для демонстрації обчислення загальної ціни продуктів.
45 fun main() {
46     val products = listOf(
47         Product("Apple", 1.0),
48         Product("Banana", 0.5),
49         Product("Orange", 0.75)
50     )
51     
52     val totalPrice = calculateTotalPrice(products)
53     println("Total price: $totalPrice")
54 }


ДОДАТОК Е
Приклади поганого та гарного документування

1 //Поганий приклад
2 // Клас для управління обліковими записами користувачів
3 class UserAccountManager {
4     // Додає нового користувача
5     fun addUser(name: String, age: Int) {
6         // Реєструємо користувача з іменем та віком
7         println("User $name, $age years old, added.")
8     }
9 
10     // Виводить інформацію про користувача
11     fun printUserInfo(name: String) {
12         // Виводимо ім'я користувача
13         println("User name: $name")
14     }
15 }
16 
17 fun main() {
18     val manager = UserAccountManager()
19     manager.addUser("Yaroslav", 19)
20     manager.printUserInfo("Yaroslav")
21 }
22 //Гарний приклад
23 /**
24  * Клас для управління обліковими записами користувачів.
25  */
26 class UserAccountManager {
27 
28     /**
29      * Додає нового користувача.
30      *
31      * @param name ім'я користувача
32      * @param age вік користувача
33      * @throws IllegalArgumentException якщо вік користувача менше 0
34      */
35     fun addUser(name: String, age: Int) {
36         if (age < 0) {
37             throw IllegalArgumentException("Вік не може бути менше 0")
38         }
39         println("User $name, $age years old, added.")
40     }
41 
42     /**
43      * Виводить інформацію про користувача.
44      *
45      * @param name ім'я користувача
46      */
47     fun printUserInfo(name: String) {
48         println("User name: $name")
49     }
50 }
51 
52 /**
53  * Основна функція для демонстрації використання UserAccountManager.
54  */
55 fun main() {
56     val manager = UserAccountManager()
57     manager.addUser("Yaroslav", 19)
58     manager.printUserInfo("Yaroslav")
59 }


ДОДАТОК Ж
Приклади поганого та гарного використання розширення функцій

1 //Поганий приклад
2 class StringUtils {
3     fun isPalindrome(str: String): Boolean {
4         val reversed = str.reversed()
5         return str == reversed
6     }
7 }
8 
9 fun main() {
10     val stringUtils = StringUtils()
11     val result = stringUtils.isPalindrome("level")
12     println("Is 'level' a palindrome? $result")
13 }
14 //Гарний приклад
15 fun String.isPalindrome(): Boolean {
16     val reversed = this.reversed()
17     return this == reversed
18 }
19 
20 fun main() {
21     val result = "level".isPalindrome()
22     println("Is 'level' a palindrome? $result")
23 }


ДОДАТОК И
Приклади поганого та гарного використання типової безпеки

1 //Поганий приклад
2 fun printUserDetails(user: User?) {
3     val username = user.username
4     println("Username: $username")
5 }
6 
7 fun main() {
8     val user: User? = null
9     printUserDetails(user)
10 }
11 
12 data class User(val username: String?)
13 //Гарний приклад
14 fun printUserDetails(user: User?) {
15     val username = user?.username ?: "Guest"
16     println("Username: $username")
17 }
18 
19 fun main() {
20     val user: User? = null
21     printUserDetails(user)
22 }
23 
24 data class User(val username: String?)


ДОДАТОК К
Приклади поганого та гарного використання дата класів

1 //Поганий приклад
2 class User(val name: String, val age: Int) {
3     override fun equals(other: Any?): Boolean {
4         if (this === other) return true
5         if (other !is User) return false
6 
7         if (name != other.name) return false
8         if (age != other.age) return false
9 
10         return true
11     }
12 
13     override fun hashCode(): Int {
14         var result = name.hashCode()
15         result = 31 * result + age
16         return result
17     }
18 
19     override fun toString(): String {
20         return "User(name='$name', age=$age)"
21     }
22 }
23 
24 fun main() {
25     val user1 = User("Yaroslav", 19)
26     val user2 = User("Yaroslav", 20)
27     
28     println(user1 == user2)
29     println(user1)
30 }
31 
32 //Гарний приклад
33 data class User(val name: String, val age: Int)
34 
35 fun main() {
36     val user1 = User("Yaroslav", 19)
37     val user2 = User("Yaroslav", 20)
38     
39     println(user1 == user2)
40     println(user1)
41 }


ДОДАТОК Л
Скриншоти презентації


Рисунок Л.1 – Титульний лист


Рисунок Л.2 – Пояснення щодо форматування коду



Рисунок Л.3 – Рекомендація щодо використання Ktlint


Рисунок Л.4 – Приклади поганого та гарного форматування


Рисунок Л.5 – Рекомендація щодо дотримання конвенції іменувань


Рисунок Л.6 – Приклади поганого та гарного використання конвенції іменувань


Рисунок Л.7 – Рекомендація щодо правильного найменування


Рисунок Л.8 – Приклади поганого та гарного найменування частин коду



Рисунок Л.9 – Рекомендація щодо написання коментарів


Рисунок Л.10 – Приклади поганого та гарного написання коментарів


Рисунок Л.11 – Рекомендація щодо створення документації


Рисунок Л.12 – Приклади поганого та гарного документування функціоналу


Рисунок Л.13 – Рекомендація щодо використання розширених функцій


Рисунок Л.14 – Приклади поганого та гарного використання розширення функцій


Рисунок Л.15 – Рекомендація щодо використання типової безпеки


Рисунок Л.16 – Приклади поганого та гарного використання типової безпеки


Рисунок Л.17 – Рекомендація щодо використання дата класів


Рисунок Л.18 – Приклади поганого та гарного використання дата класів


Рисунок Л.19 – Список використаних джерел


Рисунок Л.20 – Висновки
