Харківський національний університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії
    
    
    
    
    
    
ЗВІТ
з практичного заняття №2
з дисципліни  «Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення»
    
    
    
    
    
    
    Виконав
    ст. гр. ПЗПІ-22-3
    Іванов Ярослав В’ячеславович

    Перевірив
    ст. викладач катедри ПІ
    Сокорчук Ігор Петрович
    
    

    
Харків 2024
1 МЕТА РОБОТИ

     Навчитися основним методам рефакторингу коду на основі реальних прикладів з власних програмних проєктів. Навчитися ідентифікувати проблеми в коді та використовувати відповідіні методи рефакторингу для покращення його якості. 
     
2 ВСТУП

    Рефакторинг — це процес вдосконалення існуючого коду без зміни його функціональності чи поведінки. Його основною метою є підвищення якості коду, поліпшення його читабельності, спрощення підтримки та забезпечення більшої гнучкості для внесення змін у майбутньому. Завдяки рефакторингу код стає більш зрозумілим, що полегшує роботу для інших розробників, а також знижує ризик виникнення помилок, пов’язаних зі складністю або недоліками у його організації. У сучасній розробці це важливий етап підтримання високих стандартів коду, особливо у великих та довготривалих проєктах.
    Метою цієї роботи є практичне застосування трьох з основних методів рефакторингу для покращення коду. Це передбачає аналіз існуючого коду, ідентифікацію його слабких місць та вдосконалення структури за допомогою ефективних технік. Завдання дає змогу не лише зрозуміти теоретичну цінність рефакторингу, але й побачити його практичну користь, забезпечуючи ефективніше виконання завдань у реальних умовах.
    
3 ХІД РОБОТИ

     Посилання на відео з демонстраціями пояснень методів рефакторингу наведено у додатку А.
     
     
     3.1 Перший метод
     
     Перший метод рефакторингу «Заміна масиву об’єктом» буде застосовано до коду, який наведено у додатку Б на рядках 2-22.
     
     3.1.1 Опис коду до рефакторингу
     
     У версії коду до рефакторингу для зберігання інформації про відеоігри використовуються масиви рядків. Кожна гра представляється окремим масивом, де елементи масиву зберігають назву гри, середню оцінку, рік випуску та кількість проданих копій. Так, для гри The Witcher 3 створюється масив, у якому games[0][0] містить назву, games[0][1] — середню оцінку, games[0][2] — рік випуску, а games[0][3] — кількість проданих копій. Подібним чином зберігаються дані інших ігор. Для сортування ігор за середньою оцінкою використовується функція Array.Sort, яка порівнює оцінки, попередньо перетворені з рядків у числовий формат. Після сортування програма виводить інформацію про ігри в консолі.
     
     3.1.2 Опис причин необхідності застосування рефакторингу
     
     Такий підхід має низку серйозних недоліків. По-перше, масиви є неявною структурою даних, де кожен елемент позначає конкретний аспект інформації про гру, однак ці ролі не документовані в самому коді. Це робить програму важкою для читання та підтримки, оскільки зрозуміти, що означає games[0][1], можна лише за коментарями або вихідним кодом. По-друге, робота з масивами створює ризики помилок, оскільки неправильний індекс або зміна порядку даних у масиві може призвести до непередбачуваної поведінки програми. По-третє, збереження даних у вигляді рядків потребує додаткових операцій для перетворення, наприклад, під час порівняння оцінок. Це не лише ускладнює код, а й збільшує ймовірність помилок. Нарешті, розширення програми, наприклад, додавання нових характеристик ігор, вимагатиме суттєвих змін у всій логіці обробки масивів.
     
     3.1.3 Обгрунтування вибору методу рефакторингу
     Метод "Заміна масиву об’єктом" з книги Мартіна Фаулера був обраний для вирішення цих проблем, оскільки він дозволяє чітко структурувати дані, замінивши неявну структуру масиву явною структурою об’єкту класу з відповідними властивостями. Клас Game був створений для представлення відеоігор із полями для кожного аспекту даних: назви, середньої оцінки, року випуску та кількості проданих копій. Замість маніпуляції індексами масивів тепер можна звертатися до зрозумілих іменованих властивостей, таких як game.AverageRating або game.Name. Це значно покращує читабельність коду та зменшує ризик помилок. Крім того, використання об’єкта дозволяє легко додавати нові властивості або методи без зміни існуючої логіки програми.
     
     3.1.4 Аналіз коду після застосування рефакторингу
     Код після застосування методу «Заміна масиву об’єктом» наведено у додатку Б на рядках 25-69.
     Після рефакторингу код став значно більш структурованим, читабельним і легким для підтримки. Замість використання масивів із неявним порядком даних програма тепер працює з об’єктами класу Game, що забезпечує чітку типізацію даних. Поля класу та відповідні властивості однозначно описують кожен аспект гри, наприклад, назву чи середню оцінку. Це не лише підвищує зрозумілість коду, але й дозволяє уникнути помилок, пов’язаних із використанням неправильних індексів масиву. Сортування стало простішим завдяки використанню LINQ-запитів, таких як OrderByDescending, що додатково покращило читабельність та скоротило кількість коду. Новий підхід також відкриває можливості для розширення функціональності програми: можна легко додати нові поля в клас Game або визначити методи для специфічних операцій із даними. 
     Загалом, застосування методу рефакторингу зробило код більш надійним, гнучким і легким для підтримки.
     
     3.2 Другий метод
     
     Другий метод рефакторингу «Заміна помилки винятком» буде застосовано до коду, який наведено у додатку В на рядках 2-27.
     
     3.2.1 Опис коду до рефакторингу
     
     Код до рефакторингу містить метод Register, який відповідає за реєстрацію нового користувача. У цьому методі основний функціонал і логіка обробки помилок переплетені. Метод перевіряє валідність даних, використовуючи ModelState.IsValid. Якщо модель невалідна, метод одразу повертає помилку з повідомленням через BadRequest. Далі викликається метод Register сервісу _authService, результат якого перевіряється за допомогою набору умов. Якщо сервіс повертає, наприклад, інформацію про те, що електронна пошта вже використовується, метод знову повертає BadRequest з відповідним повідомленням. Інші перевірки стосуються слабкого пароля або внутрішніх помилок реєстрації. Усі ці перевірки реалізовані через умовні оператори, які повертають відповідний код помилки чи повідомлення.
     
     3.2.2 Опис причин необхідності застосування рефакторингу
     
     Метод до рефакторингу має кілька проблем. По-перше, умовні оператори значно ускладнюють читання коду, особливо якщо кількість перевірок збільшиться. Код стає громіздким, що ускладнює його модифікацію та підтримку. По-друге, такий підхід є менш гнучким, оскільки кожна нова перевірка або обробка помилки вимагає додавання нових умов, що призводить до дублювання коду та зростання його обсягу. По-третє, логіка обробки помилок переплітається з основним функціоналом, що порушує принцип єдиного обов’язку. Метод не лише відповідає за реєстрацію користувача, але й за визначення та обробку різних типів помилок, через що ускладнюється його тестування. Такий підхід може призводити до виникнення прихованих багів у разі зміни логіки реєстрації або додавання нових вимог.
     
     3.2.3 Обгрунтування вибору методу рефакторингу
     
     Метод рефакторингу "Заміна помилки винятком" був обраний, оскільки він дозволяє ізолювати логіку обробки помилок від основного функціоналу, що суттєво спрощує структуру методу. Використання винятків дає змогу уникнути дублювання умовних операторів і зосередитися на основній задачі методу — реєстрації користувача. Це також підвищує гнучкість коду, оскільки нові типи помилок можуть бути додані через створення відповідних винятків, без необхідності змінювати основний метод. Крім того, застосування винятків робить обробку помилок більш очевидною для розробника, оскільки вона винесена в окремий блок catch. Метод відповідає загальноприйнятим практикам обробки помилок у мовах програмування на зразок C#, що забезпечує кращу підтримку та розширюваність.
     
     3.2.4 Аналіз коду після застосування рефакторингу
     
     Код після застосування методу «Заміна помилки винятком» наведено у додатку В на рядках 30-61.
     Після рефакторингу метод Register став значно чистішим і структурованішим. Основна логіка реєстрації зосереджена на виклику методу _authService.Register, а обробка помилок делегується до блоку catch. Завдяки використанню винятків замість умовних операторів досягнуто чіткого розділення обов’язків: метод займається лише реєстрацією, тоді як помилки обробляються окремо. Це покращує читабельність коду, оскільки головний функціонал і логіка обробки помилок розділені. Код став гнучкішим: нові помилки можна легко додавати через введення відповідних винятків, що робить метод масштабованим. Тестування такого методу спрощується, оскільки можна окремо перевіряти сценарії обробки винятків і основну логіку. 
     Загалом, застосування цього методу рефакторингу зробило код легшим для розуміння, підтримки та розширення, що є важливою перевагою для довгострокових програмних рішень.
     
     3.3 Третій метод
     
     Третій метод рефакторингу «Заміна параметру методом» буде застосовано до коду, який наведено у додатку Г на рядках 2-38.
     
     3.3.1 Опис коду до рефакторингу
     
     Код до рефакторингу складається з двох класів: CheckerPiece, який представляє шашку, та Game, що моделює ігрову логіку. У класі CheckerPiece кожна шашка має координати (PositionX та PositionY), прапорець IsKing для позначення статусу "дамка" та IsCaptured для відображення того, чи була фігура захоплена. У класі Game реалізовано метод CalculateTurnScore, який обчислює кількість очок за хід гравця на основі того, чи є фігура дамкою, і скільки шашок було захоплено за хід. Метод приймає два параметри: об'єкт шашки piece та список захоплених фігур capturedPieces. Логіка підрахунку очок за захоплені шашки винесена в окремий метод CalculateCapturedPiecesScore, який працює зі списком capturedPieces, переданим у якості параметра. Весь код працює, але має суттєві недоліки, які ускладнюють його подальшу підтримку та модифікацію.
     
     
     
     
     3.3.2 Опис причин необхідності застосування рефакторингу
     
     Основною проблемою є використання параметра capturedPieces, який явно передається в метод CalculateTurnScore. Цей параметр є зайвим, оскільки інформацію про захоплені шашки можна отримати безпосередньо з об'єкта Game. Передача цього параметра збільшує складність коду, оскільки відповідальність за підготовку списку захоплених фігур лежить на зовнішньому виклику, що порушує принцип інкапсуляції. Це призводить до того, що зміни у логіці визначення захоплених фігур вимагатимуть модифікації коду у декількох місцях. Крім того, така структура ускладнює тестування, адже методи залежать від зовнішніх даних, які необхідно вручну готувати. Загалом, це знижує гнучкість та читабельність коду, особливо якщо в майбутньому знадобиться додати більше складної логіки.
     
     3.3.3 Обгрунтування вибору методу рефакторингу
     
     Для усунення описаних проблем доцільно застосувати метод рефакторингу "Заміна параметру методом". Цей метод дозволяє видалити параметр, замінивши його внутрішнім викликом методу, який може обчислити необхідне значення самостійно. У нашому випадку це означає, що замість передачі списку capturedPieces у метод CalculateTurnScore, ми можемо створити метод GetCapturedPieces, який повертає список захоплених шашок, базуючись на внутрішньому стані об'єкта Game. Це рішення дозволяє скоротити кількість параметрів, зменшити залежності між методами та покращити інкапсуляцію. Метод "Заміна параметру методом" ідеально підходить для цієї ситуації, оскільки переданий параметр capturedPieces є похідним і не потребує зовнішнього формування, а отже, може бути обчислений на місці.
     
     
     
     3.3.4 Аналіз коду після застосування рефакторингу
     
     Код після застосування методу «Заміна параметру методом» наведено у додатку Г на рядках 41-83.
     Після застосування методу рефакторингу код став більш структурованим та інкапсульованим. Було видалено параметр capturedPieces з методу CalculateTurnScore. Тепер замість нього використовується внутрішній метод GetCapturedPieces, який отримує список захоплених шашок із внутрішнього стану гри. Логіка визначення захоплених шашок повністю ізольована в одному місці, що дозволяє легко її змінювати без ризику впливу на інші частини програми. Це зробило код більш гнучким для майбутнього розширення, наприклад, якщо потрібно буде додати нові правила визначення захоплених фігур. 
     Загалом, використання цього методу рефакторингу спростило взаємодію між методами, зробило їх більш зрозумілими і полегшило підтримку. 
     Слайди презентації, що ілюструють результати виконання даної практичної роботи наведено у додатку Д.

ВИСНОВКИ

     Під час виконання лабораторної роботи ми навчилися основним методам рефакторингу коду на основі реальних прикладів з власних програмних проєктів. Була набута навичка ідентифікувати проблеми в коді та використовувати відповідіні методи рефакторингу для покращення його якості.


СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ

     1. Мартін Ф. (2018). Refactoring: Improving the Design of Existing Code. (дата звернення: 12.12.2024).
ДОДАТОК А
Відео-посилання на YouTube

     https://youtu.be/BvUrL9TNIDQ

     
ДОДАТОК Б
Код до та після застосування методу «Заміна масива об’єктом»

1 //До рефакторингу
2 using System;
3 
4 class Program
5 {
6     static void Main(string[] args)
7     {
8         string[][] games = new string[3][];
9         
10         games[0] = new string[] { "The Witcher 3", "9.5", "2015", "40000000" };
11         games[1] = new string[] { "Cyberpunk 2077", "7.8", "2020", "20000000" };
12         games[2] = new string[] { "Red Dead Redemption 2", "9.8", "2018", "50000000" };
13         
14         Array.Sort(games, (a, b) => double.Parse(b[1]).CompareTo(double.Parse(a[1])));
15         
16         Console.WriteLine("Ігри за середніми оцінками (від найвищої):");
17         foreach (var game in games)
18         {
19             Console.WriteLine($"Назва: {game[0]}, Середня оцінка: {game[1]}, Рік випуску: {game[2]}, Продані копії: {game[3]}");
20         }
21     }
22 }
23 
24 //Після рефакторингу
25 using System;
26 using System.Collections.Generic;
27 using System.Linq;
28 
29 class Game
30 {
31     public string Name { get; set; }
32     public double AverageRating { get; set; }
33     public int ReleaseYear { get; set; }
34     public long CopiesSold { get; set; }
35 
36     public Game(string name, double averageRating, int releaseYear, long copiesSold)
37     {
38         Name = name;
39         AverageRating = averageRating;
40         ReleaseYear = releaseYear;
41         CopiesSold = copiesSold;
42     }
43 
44     public override string ToString()
45     {
46         return $"Назва: {Name}, Середня оцінка: {AverageRating}, Рік випуску: {ReleaseYear}, Продані копії: {CopiesSold}";
47     }
48 }
49 
50 class Program
51 {
52     static void Main(string[] args)
53     {
54         List<Game> games = new List<Game>
55         {
56             new Game("The Witcher 3", 9.5, 2015, 40000000),
57             new Game("Cyberpunk 2077", 7.8, 2020, 20000000),
58             new Game("Red Dead Redemption 2", 9.8, 2018, 50000000)
59         };
60 
61         var sortedGames = games.OrderByDescending(game => game.AverageRating).ToList();
62 
63         Console.WriteLine("Ігри за середніми оцінками (від найвищої):");
64         foreach (var game in sortedGames)
65         {
66             Console.WriteLine(game);
67         }
68     }
69 }
ДОДАТОК В
Код до та після застосування методу «Заміна помилки на виняток»

1 //До рефакторингу
2 [HttpPost("register")]
3 [SwaggerOperation("Register user")]
4 public async Task<IActionResult> Register([FromBody] RegistrationUserRequest request)
5 {
6     if (!ModelState.IsValid)
7     {
8         return BadRequest("Invalid model state.");
9     }
10 
11     var userResult = await _authService.Register(request.Username, request.Password, request.Email);
12 
13     if (userResult == null)
14     {
15         return StatusCode(500, "Registration failed due to an internal error.");
16     }
17     if (userResult.IsDuplicateEmail)
18     {
19         return BadRequest("Email is already in use.");
20     }
21     if (userResult.IsWeakPassword)
22     {
23         return BadRequest("Password is too weak.");
24     }
25 
26     return Ok(userResult);
27 }
28 
29 //Після рефакторингу
30 [HttpPost("register")]
31 [SwaggerOperation("Register user")]
32 public async Task<IActionResult> Register([FromBody] RegistrationUserRequest request)
33 {
34     try
35     {
36         if (!ModelState.IsValid)
37         {
38             throw new ArgumentException("Invalid model state.");
39         }
40 
41         var userResult = await _authService.Register(request.Username, request.Password, request.Email);
42 
43         return Ok(userResult);
44     }
45     catch (DuplicateEmailException)
46     {
47         return BadRequest("Email is already in use.");
48     }
49     catch (WeakPasswordException)
50     {
51         return BadRequest("Password is too weak.");
52     }
53     catch (ArgumentException e)
54     {
55         return BadRequest(e.Message);
56     }
57     catch (Exception e)
58     {
59         return StatusCode(500, $"Registration failed: {e.Message}");
60     }
61 }
ДОДАТОК Г
Код до та після застосування методу «Заміна параметру методом»

1 //До рефакторингу
2 public class CheckerPiece
3 {
4     public int PositionX { get; set; }
5     public int PositionY { get; set; }
6     public bool IsKing { get; set; }
7     public bool IsCaptured { get; set; }
8 
9     public CheckerPiece(int x, int y, bool isKing)
10     {
11         PositionX = x;
12         PositionY = y;
13         IsKing = isKing;
14         IsCaptured = false;
15     }
16 }
17 
18 public class Game
19 {
20     private List<CheckerPiece> _allPieces;
21 
22     public Game(List<CheckerPiece> pieces)
23     {
24         _allPieces = pieces;
25     }
26 
27     public int CalculateTurnScore(CheckerPiece piece, List<CheckerPiece> capturedPieces)
28     {
29         int baseScore = piece.IsKing ? 15 : 10;
30         int capturedScore = CalculateCapturedPiecesScore(capturedPieces);
31         return baseScore + capturedScore;
32     }
33 
34     private int CalculateCapturedPiecesScore(List<CheckerPiece> capturedPieces)
35     {
36         return capturedPieces.Count * 5;
37     }
38 }
39 
40 //Після рефакторингу
41 public class CheckerPiece
42 {
43     public int PositionX { get; set; }
44     public int PositionY { get; set; }
45     public bool IsKing { get; set; }
46     public bool IsCaptured { get; set; }
47 
48     public CheckerPiece(int x, int y, bool isKing)
49     {
50         PositionX = x;
51         PositionY = y;
52         IsKing = isKing;
53         IsCaptured = false;
54     }
55 }
56 
57 public class Game
58 {
59     private List<CheckerPiece> _allPieces;
60 
61     public Game(List<CheckerPiece> pieces)
62     {
63         _allPieces = pieces;
64     }
65 
66     private List<CheckerPiece> GetCapturedPieces()
67     {
68         return _allPieces.Where(piece => piece.IsCaptured).ToList();
69     }
70 
71     public int CalculateTurnScore(CheckerPiece piece)
72     {
73         int baseScore = piece.IsKing ? 15 : 10;
74         int capturedScore = CalculateCapturedPiecesScore();
75         return baseScore + capturedScore;
76     }
77 
78     private int CalculateCapturedPiecesScore()
79     {
80         var capturedPieces = GetCapturedPieces();
81         return capturedPieces.Count * 5;
82     }
83 }
ДОДАТОК Д
Скриншоти презентації


Рисунок Д.1 – Титульний лист


Рисунок Д.2 – Зміст презентації



Рисунок Д.3 – Вступ


Рисунок Д.4 – Опис першого методу рефакторингу


Рисунок Д.5 – Приклад коду до застосування першого методу рефакторингу


Рисунок Д.6 – Приклад коду після застосування першого методу рефакторингу


Рисунок Д.7 – Опис другого методу рефакторингу


Рисунок Д.8 – Приклад коду до застосування другого методу рефакторингу



Рисунок Д.9 – Приклад коду після застосування другого методу рефакторингу


Рисунок Д.10 – Опис третього методу рефакторингу


Рисунок Д.11 – Приклад коду до застосування третього методу рефакторингу


Рисунок Д.12 – Приклад коду після застосування третього методу рефакторингу



Рисунок Д.13 – Інструменти рефакторингу коду


Рисунок Д.14 – Висновки роботи


Рисунок Д.15 – Список використаних джерел